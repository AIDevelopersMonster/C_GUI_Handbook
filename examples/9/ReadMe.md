

# Глава 9: Ввод с клавиатуры

В этой главе мы глубоко разберем, как организовать **ввод данных от пользователя** через клавиатуру в языке C. Вы узнаете, как эффективно использовать функции **`scanf`** и **`fgets`**, научитесь **избегать опасного переполнения буфера** и обеспечите безопасную и надежную работу со строками.

-----

## Введение в ввод данных

Взаимодействие с пользователем — ключевая часть большинства программ. В языке C для чтения данных с клавиатуры используются функции из стандартной библиотеки ввода/вывода `stdio.h`. Однако, некоторые из них, особенно при работе со строками, требуют особого внимания к безопасности.

-----

## Пример 1: Безопасный ввод чисел с помощью `scanf`

Функция `scanf` идеально подходит для чтения форматированных данных, таких как числа и отдельные символы. Однако, **крайне важно проверять её возвращаемое значение**, чтобы убедиться, что ввод был успешным. `scanf` возвращает количество успешно прочитанных элементов.

**Код:** `chapter9_example1.c`

```c
#include <stdio.h> // Подключаем стандартную библиотеку ввода/вывода

int main() {
    int age; // Объявляем целочисленную переменную для хранения возраста

    printf("Введите ваш возраст: ");

    // Безопасный ввод числа: проверяем, что scanf успешно прочитал 1 элемент
    if (scanf("%d", &age) == 1) {
        printf("Ваш возраст: %d\n", age);
    } else {
        printf("Ошибка: Вы ввели не число. Пожалуйста, введите корректный возраст.\n");
        // Очищаем буфер stdin, чтобы избежать проблем со следующим вводом,
        // если пользователь ввел некорректные данные (например, текст)
        while (getchar() != '\n' && getchar() != EOF);
    }

    return 0;
}
```

**Комментарий:**

  * **`scanf("%d", &age);`**: `**%d**` — это спецификатор формата для чтения целого числа. `**&age**` — это адрес переменной `age`, куда `scanf` запишет прочитанное значение.
  * **Проверка `scanf() == 1`**: Это критично для **обработки ошибок**. Если пользователь введет "двадцать" вместо `20`, `scanf` не сможет прочитать целое число, и программа сможет корректно отреагировать.
  * **Очистка буфера**: Если `scanf` не удалось прочитать ожидаемый формат, некорректные символы остаются в буфере ввода. `while (getchar() != '\n' && getchar() != EOF);` очищает буфер до конца строки или EOF, предотвращая проблемы с последующими операциями ввода.

-----

## Пример 2: Опасности `scanf` при вводе строк

Использование `scanf("%s", ...)` для чтения строк **крайне небезопасно** и является **распространенной причиной переполнения буфера**. `scanf("%s", ...)` не знает размера выделенного буфера и будет продолжать записывать символы, пока не встретит пробел или символ новой строки, потенциально выходя за границы массива.

**Код:** `chapter9_example2.c`

```c
#include <stdio.h> // Подключаем стандартную библиотеку ввода/вывода

int main() {
    // Объявляем символьный массив (строку) размером 10 символов.
    // Это означает, что он может хранить 9 символов + завершающий нулевой символ '\0'.
    char name[10];

    printf("Введите имя: ");

    // ⚠️ ПОТЕНЦИАЛЬНО НЕБЕЗОПАСНОЕ ИСПОЛЬЗОВАНИЕ scanf !!!
    // %s - спецификатор формата для чтения строки.
    // scanf читает символы до пробела, символа новой строки или EOF.
    // ОН НЕ ПРОВЕРЯЕТ РАЗМЕР БУФЕРА!
    // Если пользователь введет более 9 символов, произойдет ПЕРЕПОЛНЕНИЕ БУФЕРА.
    scanf("%s", name);

    printf("Привет, %s!\n", name);

    return 0;
}
```

**Важно:**

  * Если вы введете имя длиннее 9 символов (например, "ДлинноеИмя"), программа запишет данные за пределы массива `name`, что приведет к **неопределенному поведению** (сбоям, уязвимостям).

-----

## Пример 3: Безопасный ввод строк с помощью `fgets`

Функция `fgets` является **предпочтительным и безопасным способом** чтения строк в C. Она позволяет указать максимальное количество символов для чтения, тем самым **предотвращая переполнение буфера**.

**Код:** `chapter9_example3.c`

```c
#include <stdio.h>  // Подключаем стандартную библиотеку ввода/вывода
#include <string.h> // Подключаем библиотеку для работы со строками (для strcspn)

int main() {
    // Объявляем символьный массив (строку) размером 20 символов.
    // Этого достаточно для 19 символов + завершающий нулевой символ '\0'.
    char name[20];

    printf("Введите имя: ");

    //  БЕЗОПАСНЫЙ ввод строки с помощью fgets
    // 1. name: указатель на буфер, куда будут записаны символы.
    // 2. sizeof(name): максимальное количество символов для чтения (включая '\0').
    //    fgets прочитает до (размер буфера - 1) символа ИЛИ до символа новой строки.
    // 3. stdin: файловый поток, откуда читать (стандартный ввод, т.е. клавиатура).
    // fgets возвращает NULL в случае ошибки или EOF.
    if (fgets(name, sizeof(name), stdin) != NULL) {
        // fgets сохраняет символ новой строки '\n', если он был прочитан и поместился в буфер.
        // Это часто нежелательно, поэтому удаляем его.
        name[strcspn(name, "\n")] = '\0'; // strcspn находит индекс первого '\n' и заменяет его на '\0'

        printf("Привет, %s!\n", name);
    } else {
        printf("Ошибка при чтении имени.\n");
    }

    return 0;
}
```

**Комментарий:**

  * **`fgets(name, sizeof(name), stdin);`**: Это ключевая часть. `fgets` гарантирует, что не будет прочитано больше символов, чем может поместиться в `name`, включая завершающий `\0`.
  * **`name[strcspn(name, "\n")] = '\0';`**: `fgets` включает символ новой строки (`\n`), если он был введен и поместился в буфер. Эта строка кода находит позицию `\n` (если он есть) и заменяет его на завершающий нулевой символ `\0`, эффективно "обрезая" строку. Это делает вывод более чистым.

-----

## Работа с символом новой строки (`\n`) и очистка буфера

После использования `scanf` для чтения чисел или одиночных символов, символ новой строки (`\n`), оставшийся от нажатия `Enter` пользователем, может остаться в буфере `stdin`. Это может привести к неожиданному поведению при последующих вызовах функций ввода, таких как `fgets` или `getchar()`.

**Пример проблемы:**

```c
#include <stdio.h>

int main() {
    int num;
    char text[100];

    printf("Введите число: ");
    scanf("%d", &num); // Пользователь вводит "123" и нажимает Enter. '\n' остается в буфере.

    printf("Введите текст: ");
    // fgets немедленно прочитает оставшийся '\n' из буфера и "подумает", что ввод завершен.
    fgets(text, sizeof(text), stdin);

    printf("Число: %d, Текст: %s\n", num, text);
    return 0;
}
```

**Решение: Очистка буфера `stdin`**

Чтобы избежать этой проблемы, вы можете очистить буфер ввода после `scanf` (если ожидаете дальнейший ввод):

```c
// Функция для очистки буфера ввода
void clear_input_buffer() {
    int c;
    while ((c = getchar()) != '\n' && c != EOF);
}

// Пример использования
#include <stdio.h>

void clear_input_buffer(); // Прототип функции

int main() {
    int num;
    char text[100];

    printf("Введите число: ");
    if (scanf("%d", &num) == 1) {
        clear_input_buffer(); // Очищаем буфер после scanf

        printf("Введите текст: ");
        fgets(text, sizeof(text), stdin);
        text[strcspn(text, "\n")] = '\0'; // Удаляем '\n' от fgets

        printf("Число: %d, Текст: %s\n", num, text);
    } else {
        printf("Ошибка: Некорректный ввод числа.\n");
        clear_input_buffer(); // Очищаем буфер после некорректного ввода
    }

    return 0;
}

void clear_input_buffer() {
    int c;
    while ((c = getchar()) != '\n' && c != EOF);
}
```

-----

## Общие рекомендации по безопасному вводу

  * **Для числового ввода**: Используйте `scanf` с **обязательной проверкой возвращаемого значения** (`== количество_ожидаемых_элементов`). После `scanf`, если ожидается ввод строки, **очищайте буфер `stdin`**.
  * **Для строкового ввода**: **Всегда используйте `fgets`**. Это ваш основной инструмент для чтения строк с клавиатуры, так как он позволяет контролировать размер буфера и предотвращает переполнение.
  * **Обработка `\n` от `fgets`**: Помните, что `fgets` включает символ `\n` в строку, если он помещается в буфер. Используйте `strcspn` или другие строковые функции для его удаления, если он не нужен.
  * **Размер буфера**: Всегда выделяйте достаточный размер буфера для хранения ожидаемых данных, плюс один символ для завершающего `\0`.

-----

## Компиляция и запуск примеров

Сохраните каждый пример кода в отдельный `.c` файл (например, `chapter9_example1.c`, `chapter9_example2.c`, `chapter9_example3.c`).

Для компиляции используйте компилятор GCC:

```bash
# Компиляция первого примера
gcc chapter9_example1.c -o example1

# Запуск первого примера
./example1

# Компиляция второго примера
gcc chapter9_example2.c -o example2

# Запуск второго примера
./example2

# Компиляция третьего примера
gcc chapter9_example3.c -o example3

# Запуск третьего примера
./example3
```

-----

## Дополнительные ресурсы

  *  [C Programming - Input and Output (cplusplus.com)](https://www.cplusplus.com/reference/cstdio/)
  *  [Функция fgets (cplusplus.com)](https://www.cplusplus.com/reference/cstdio/fgets/)
  *  [Почему scanf опасен — статья на Stack Overflow (на английском)](https://www.google.com/search?q=https://stackoverflow.com/questions/2202678/why-is-scanf-so-dangerous-and-what-are-the-alternatives)
  *  [Статья о безопасном вводе в C (на английском)](https://www.google.com/search?q=https://www.geeksforgeeks.org/gets-vs-fgets/)

-----
