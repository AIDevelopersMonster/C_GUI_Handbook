# Глава 10: Работа с файлами

В этой главе мы рассмотрим основы работы с файлами в языке C. Работа с файлами позволяет сохранять и считывать данные вне оперативной памяти, делая программы более полезными и долговечными.

Мы изучим:

  * Открытие файлов (`fopen`)
  * Чтение и запись (`fread`, `fwrite`, `fprintf`, `fscanf`)
  * Закрытие файлов (`fclose`)
  * Проверку ошибок при работе с файлами
  * Примеры чтения и записи текстовых и бинарных файлов

-----

Работа с файлами в C — это фундаментальный навык, который позволяет вашим программам взаимодействовать с внешним миром. Когда вы запускаете программу, все её данные хранятся в **оперативной памяти (RAM)**. Как только программа завершает работу, эти данные исчезают. Файлы предоставляют способ **постоянного хранения данных** на диске, чтобы они сохранялись между запусками программы или могли быть доступны другим программам.

По сути, файл — это просто упорядоченная последовательность байтов. Однако, когда мы говорим о файлах в контексте программирования, мы часто различаем **текстовые файлы** и **бинарные файлы**.

  * **Текстовые файлы** содержат символы, которые человек может прочитать, например, обычный текст. Каждый символ хранится как его соответствующее кодирование (например, ASCII или UTF-8).
  * **Бинарные файлы** хранят данные в том виде, в котором они представлены в памяти компьютера (например, целые числа, структуры). Эти файлы обычно не предназначены для чтения человеком напрямую и требуют специального программного обеспечения для интерпретации.

Стандартная библиотека ввода/вывода C (`stdio.h`) предоставляет набор функций для работы с файлами. Все эти функции оперируют с указателями на тип `FILE`, который представляет собой абстракцию файла.

-----

### Основные функции для работы с файлами

#### Открытие файлов: `fopen()`

Прежде чем вы сможете читать из файла или записывать в него, вам нужно его **открыть**. Для этого используется функция `fopen()`.

```c
FILE *fopen(const char *filename, const char *mode);
```

  * `filename`: Строка, содержащая имя файла, который вы хотите открыть.
  * `mode`: Строка, указывающая режим открытия файла.

Вот наиболее часто используемые режимы:

.. list-table:: Режимы открытия файлов
:widths: 15 85
:header-rows: 1

  *   - Режим
      - Описание
  *   - `"r"`
      - Открыть для чтения. Файл должен существовать.
  *   - `"w"`
      - Открыть для записи. Если файл существует, его содержимое **удаляется**. Если нет, файл создается.
  *   - `"a"`
      - Открыть для добавления (дозаписи). Запись происходит в конец файла. Если файл не существует, он создается.
  *   - `"rb"`
      - Открыть для чтения в бинарном режиме.
  *   - `"wb"`
      - Открыть для записи в бинарном режиме. Если файл существует, его содержимое **удаляется**. Если нет, файл создается.
  *   - `"ab"`
      - Открыть для добавления в бинарном режиме. Запись происходит в конец файла. Если файл не существует, он создается.
  *   - `"r+"`
      - Открыть для чтения и записи. Файл должен существовать.
  *   - `"w+"`
      - Открыть для чтения и записи. Если файл существует, его содержимое **удаляется**. Если нет, файл создается.
  *   - `"a+"`
      - Открыть для чтения и добавления. Запись происходит в конец файла. Если файл не существует, он создается.

Функция `fopen()` возвращает указатель на `FILE`, который будет использоваться во всех последующих операциях с этим файлом. Если файл не может быть открыт (например, из-за отсутствия прав, или файл не существует в режиме `"r"`), `fopen()` возвращает `NULL`. **Всегда проверяйте возвращаемое значение `fopen()`\!**

#### Закрытие файлов: `fclose()`

Когда вы закончили работу с файлом, очень важно его **закрыть**. Функция `fclose()` освобождает ресурсы, связанные с файлом, и гарантирует, что все буферизованные данные будут записаны на диск.

```c
int fclose(FILE *fp);
```

  * `fp`: Указатель на `FILE`, возвращенный `fopen()`.

`fclose()` возвращает `0` в случае успешного закрытия или `EOF` (End Of File) в случае ошибки. Не закрытые файлы могут привести к потере данных или ошибкам в программе.

#### Чтение и запись текстовых данных

Для работы с текстовыми файлами часто используются функции, похожие на `printf()` и `scanf()`, но с добавлением указателя на файл:

  * `fprintf(FILE *fp, const char *format, ...)`: Записывает форматированные данные в файл. Аналогична `printf()`, но пишет в файл.
  * `fscanf(FILE *fp, const char *format, ...)`: Считывает форматированные данные из файла. Аналогична `scanf()`, но читает из файла.
  * `fgetc(FILE *fp)`: Считывает один символ из файла.
  * `fputc(int char_val, FILE *fp)`: Записывает один символ в файл.
  * `fgets(char *buffer, int size, FILE *fp)`: Считывает строку из файла. Читает до `size-1` символов или до символа новой строки, или до конца файла. Возвращает `NULL` при ошибке или достижении конца файла.
  * `fputs(const char *str, FILE *fp)`: Записывает строку в файл.

#### Чтение и запись бинарных данных

Для работы с бинарными файлами используются функции `fread()` и `fwrite()`:

  * `size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *fp);`
      * `ptr`: Указатель на массив или переменную, данные которой нужно записать.
      * `size`: Размер одного элемента в байтах (часто `sizeof(тип)`).
      * `nmemb`: Количество элементов, которые нужно записать.
      * `fp`: Указатель на `FILE`.
      * Возвращает количество успешно записанных элементов.
  * `size_t fread(void *ptr, size_t size, size_t nmemb, FILE *fp);`
      * `ptr`: Указатель на буфер, куда будут считаны данные.
      * `size`: Размер одного элемента в байтах.
      * `nmemb`: Максимальное количество элементов, которое нужно считать.
      * `fp`: Указатель на `FILE`.
      * Возвращает количество успешно считанных элементов.

Эти функции очень мощные, так как позволяют читать и записывать целые структуры данных или массивы за один вызов, что эффективно для бинарных данных.

-----

## Пример 1: Запись строки в файл

Название файла: `write_to_file.c`

```c
#include <stdio.h> // Подключаем стандартную библиотеку ввода/вывода, необходимую для работы с файлами (например, fopen, fprintf, fclose).

int main() {
    // Объявляем указатель на FILE. Тип FILE - это структура, которая используется для управления потоком данных файла.
    // Указатель 'fp' (file pointer) будет нашим "дескриптором" для взаимодействия с файлом.
    FILE *fp = fopen("output.txt", "w"); // Функция fopen() открывает файл.
                                         // "output.txt" - имя файла, который мы хотим открыть.
                                         // "w" - режим открытия: "write" (запись).
                                         // Если файл "output.txt" не существует, он будет создан.
                                         // Если файл существует, его текущее содержимое будет стерто (перезаписано).

    // Проверяем, успешно ли открыт файл.
    // Если fopen() не удалось открыть файл (например, из-за отсутствия прав или недопустимого пути),
    // она возвращает NULL. Это критически важная проверка для надежных программ.
    if (fp == NULL) {
        printf("Не удалось открыть файл для записи.\n"); // Выводим сообщение об ошибке на консоль.
        return 1; // Возвращаем ненулевой код (принято 1), чтобы указать операционной системе, что программа завершилась с ошибкой.
    }

    // Записываем форматированную строку в открытый файл.
    // fprintf() работает так же, как printf(), но первый аргумент - это указатель на FILE,
    // указывающий, куда именно нужно записать данные (в данном случае, в "output.txt").
    fprintf(fp, "Привет, файл!\n"); // Записываем строку "Привет, файл!" с символом новой строки в конце.

    // Закрываем файл.
    // fclose() освобождает все системные ресурсы, связанные с файлом, и гарантирует,
    // что все буферизованные данные (которые могли быть временно сохранены в памяти)
    // будут записаны на диск. Это очень важный шаг, чтобы избежать потери данных
    // и утечек ресурсов.
    fclose(fp);

    printf("Строка успешно записана в output.txt\n"); // Сообщаем пользователю об успешном завершении операции.
    return 0; // Возвращаем 0, чтобы указать операционной системе, что программа завершилась успешно.
}
```

-----

## Пример 2: Чтение файла построчно

Название файла: `read_line_by_line.c`

```c
#include <stdio.h> // Подключаем стандартную библиотеку ввода/вывода.

int main() {
    // Открываем файл "output.txt" в режиме чтения.
    // "r" - режим "read" (чтение). Файл должен существовать, иначе fopen вернет NULL.
    FILE *fp = fopen("output.txt", "r");

    // Проверяем, успешно ли открыт файл.
    if (fp == NULL) {
        printf("Не удалось открыть файл для чтения. Убедитесь, что 'output.txt' существует.\n");
        return 1; // Код ошибки.
    }

    // Объявляем буфер (массив символов) для временного хранения каждой считанной строки.
    // Размер 256 байт означает, что мы можем прочитать строку длиной до 255 символов,
    // плюс один байт для завершающего нулевого символа ('\0'), который автоматически добавляется fgets.
    char buffer[256];

    printf("Чтение содержимого файла 'output.txt':\n");
    // Используем цикл while и функцию fgets для чтения файла построчно.
    // fgets(буфер, размер_буфера, указатель_на_файл)
    // - 'buffer': указатель на массив, куда будет считана строка.
    // - 'sizeof(buffer)': максимальное количество символов для чтения (включая '\0').
    // - 'fp': указатель на открытый файл.
    // fgets читает символы из файла до тех пор, пока не встретит символ новой строки ('\n'),
    // или не достигнет конца файла (EOF), или не прочтет 'size - 1' символов.
    // Символ новой строки, если он есть в файле, также включается в буфер.
    // Функция возвращает 'buffer' при успешном чтении или NULL при достижении конца файла или ошибке.
    while (fgets(buffer, sizeof(buffer), fp)) {
        printf("Считано: %s", buffer); // Выводим считанную строку на консоль.
                                       // Поскольку fgets уже включает '\n' (если он был в файле),
                                       // нам не нужно добавлять свой '\n' здесь, чтобы избежать двойных переносов строки.
    }

    // Закрываем файл.
    // Это освобождает ресурсы и завершает все операции с файлом.
    fclose(fp);

    printf("Чтение файла завершено.\n");
    return 0; // Успешное завершение.
}
```

-----

## Пример 3: Запись и чтение бинарного файла

Название файла: `binary_file_rw.c`

```c
#include <stdio.h> // Подключаем стандартную библиотеку ввода/вывода.

int main() {
    // --- Часть 1: Запись в бинарный файл ---
    int numbers[] = {1, 2, 3, 4, 5}; // Объявляем массив целых чисел для записи.

    // Открываем файл "numbers.bin" в режиме бинарной записи.
    // "wb" - "write binary" (запись в бинарном режиме).
    // Важно использовать 'b' для бинарных файлов, особенно в некоторых операционных системах,
    // чтобы избежать автоматической конвертации символов новой строки (например, '\n' в '\r\n').
    FILE *fp = fopen("numbers.bin", "wb");

    // Проверяем, успешно ли открыт файл.
    if (fp) { // Упрощенная проверка: NULL интерпретируется как false, не-NULL как true.
        // Записываем массив чисел в файл.
        // fwrite(указатель_на_данные, размер_одного_элемента, количество_элементов, указатель_на_файл)
        // - 'numbers': указатель на начало данных, которые нужно записать.
        // - 'sizeof(int)': размер одного элемента (целого числа) в байтах.
        // - '5': количество элементов, которые мы хотим записать из массива 'numbers'.
        // - 'fp': указатель на файл.
        // fwrite возвращает количество успешно записанных элементов.
        fwrite(numbers, sizeof(int), 5, fp);
        fclose(fp); // Закрываем файл после записи.
        printf("Массив чисел успешно записан в numbers.bin\n");
    } else {
        printf("Ошибка: Не удалось открыть файл 'numbers.bin' для записи.\n");
        return 1; // Код ошибки.
    }

    // --- Часть 2: Чтение из бинарного файла ---
    int read_numbers[5]; // Объявляем массив для хранения чисел, считанных из файла.
                         // Размер должен быть достаточным для хранения всех ожидаемых данных.

    // Открываем тот же файл "numbers.bin" в режиме бинарного чтения.
    // "rb" - "read binary" (чтение в бинарном режиме).
    fp = fopen("numbers.bin", "rb");

    // Проверяем, успешно ли открыт файл для чтения.
    if (fp) {
        // Считываем данные из файла в массив read_numbers.
        // fread(указатель_на_буфер, размер_одного_элемента, количество_элементов, указатель_на_файл)
        // - 'read_numbers': указатель на буфер, куда будут помещены считанные данные.
        // - 'sizeof(int)': размер одного элемента.
        // - '5': максимальное количество элементов, которые мы хотим считать.
        // - 'fp': указатель на файл.
        // fread возвращает количество успешно считанных элементов.
        fread(read_numbers, sizeof(int), 5, fp);
        fclose(fp); // Закрываем файл после чтения.

        printf("Числа, считанные из 'numbers.bin': ");
        // Выводим считанные числа на консоль, чтобы убедиться, что они были прочитаны корректно.
        for (int i = 0; i < 5; i++) {
            printf("%d ", read_numbers[i]);
        }
        printf("\n");
    } else {
        printf("Ошибка: Не удалось открыть файл 'numbers.bin' для чтения.\n");
        return 1; // Код ошибки.
    }

    return 0; // Успешное завершение программы.
}
```

-----

## Компиляция и Запуск Всех Примеров

Для компиляции и запуска этих примеров на Unix-подобных системах (Linux, macOS) или в MinGW/Cygwin на Windows, вы можете использовать компилятор GCC.

**1. Компиляция:**

Откройте терминал и перейдите в директорию, где сохранены ваши файлы `.c`. Затем скомпилируйте каждый файл отдельно:

```bash
gcc write_to_file.c -o write_to_file
gcc read_line_by_line.c -o read_line_by_line
gcc binary_file_rw.c -o binary_file_rw
```

  * `gcc`: Команда для вызова компилятора GCC.
  * `your_file.c`: Имя вашего исходного файла на языке C.
  * `-o your_program_name`: Опция `-o` указывает имя исполняемого файла, который будет создан.

**2. Запуск и Ожидаемый Вывод:**

Запускайте программы в следующем порядке, так как `read_line_by_line` зависит от файла, созданного `write_to_file`.

**Пример 1: Запись строки в файл**

Запуск:

```bash
./write_to_file
```

Ожидаемый вывод на консоль:

```
Строка успешно записана в output.txt
```

После запуска этой программы в той же директории будет создан файл `output.txt` со следующим содержимым:

```
Привет, файл!
```

**Пример 2: Чтение файла построчно**

Запуск:

```bash
./read_line_by_line
```

Ожидаемый вывод на консоль:

```
Чтение содержимого файла 'output.txt':
Считано: Привет, файл!
Чтение файла завершено.
```

**Пример 3: Запись и чтение бинарного файла**

Запуск:

```bash
./binary_file_rw
```

Ожидаемый вывод на консоль:

```
Массив чисел успешно записан в numbers.bin
Числа, считанные из 'numbers.bin': 1 2 3 4 5
```

После запуска этой программы в той же директории будет создан файл `numbers.bin`. Его содержимое будет бинарным и не предназначено для прямого чтения текстовым редактором.

-----

## Навигация

  * :ref:`Глава 9: Ввод с клавиатуры <Глава 9: Ввод с клавиатуры>`
  * :ref:`Глава 11: Основы графического интерфейса <Глава 11: Основы графического интерфейса>`

-----

## Дополнительные Ресурсы для Глубокого Погружения

  * **Официальная документация C по `stdio.h`**: Самый авторитетный источник информации обо всех функциях ввода/вывода в C.
  * **Практическое руководство (cppreference.com)**: [https://en.cppreference.com/w/c/io](https://en.cppreference.com/w/c/io) - Отличный ресурс с подробным описанием каждой функции, примерами и информацией о возможных ошибках.
  * **Статья "File I/O in C" на GeeksforGeeks**: Часто содержит хорошие объяснения и дополнительные примеры для начинающих: [https://www.geeksforgeeks.org/file-input-output-in-c-language/](https://www.google.com/search?q=https://www.geeksforgeeks.org/file-input-output-in-c-language/)

-----

Надеюсь, это дополнение сделает главу еще более полной и полезной\!