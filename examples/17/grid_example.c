#include <gtk/gtk.h> // Подключаем основную библиотеку GTK.
                       // Этот заголовочный файл содержит все необходимые определения
                       // для создания графических интерфейсов с помощью GTK.

/**
 * @brief Callback-функция, которая будет вызвана при нажатии любой кнопки.
 *
 * Эта функция извлекает метку (текст) с нажатой кнопки и выводит её в консоль.
 * Это очень полезно для отладки или для демонстрации, какая именно кнопка
 * была активирована пользователем.
 *
 * @param widget Указатель на GtkWidget, который испустил сигнал.
 * В данном случае, это будет указатель на GtkButton, которая была нажата.
 * Хотя мы не используем его для изменения состояния кнопки,
 * мы используем его для получения текста с кнопки.
 * @param data   Универсальный указатель на пользовательские данные.
 * В этом конкретном примере мы передаём NULL, так как никаких
 * дополнительных данных этой функции не требуется.
 */
static void on_button_clicked(GtkWidget *widget, gpointer data) {
    // Получаем текст с кнопки.
    // GTK_BUTTON(widget) - это макрос приведения типа (cast), который преобразует
    // универсальный GtkWidget* в более специфичный GtkButton*. Это необходимо,
    // потому что gtk_button_get_label() ожидает указатель типа GtkButton*.
    const char *button_label = gtk_button_get_label(GTK_BUTTON(widget));
    
    // Выводим сообщение в консоль.
    // g_print() - это функция из библиотеки GLib (основы GTK), которая
    // аналогична стандартной printf(), но более адаптирована для вывода
    // из GUI-приложений GTK, особенно когда они запускаются без прямого
    // подключения к терминалу.
    g_print("Нажата кнопка: %s\n", button_label);
}

/**
 * @brief Функция активации приложения.
 *
 * Эта функция вызывается, когда GTK-приложение запускается и готово
 * к отображению своих окон. Здесь происходит вся основная логика
 * создания и компоновки элементов интерфейса.
 *
 * @param app       Указатель на объект GtkApplication.
 * GtkApplication - это новый, рекомендуемый способ создания
 * GTK-приложений, который упрощает управление жизненным циклом
 * приложения, обработку аргументов командной строки и многое другое.
 * @param user_data Универсальный указатель на пользовательские данные,
 * переданные при подключении сигнала "activate". В данном случае NULL.
 */
static void activate(GtkApplication *app, gpointer user_data) {
    GtkWidget *window;                      // Объявляем указатель на главное окно.
    GtkWidget *grid;                        // Объявляем указатель на контейнер GtkGrid.
    GtkWidget *button1, *button2, *button3, *button4; // Объявляем указатели для наших кнопок.

    // 1. Создание главного окна приложения.
    // gtk_application_window_new(app) создает окно, которое автоматически
    // связывается с объектом GtkApplication. Это помогает GTK лучше управлять
    // приложением, особенно при работе с несколькими окнами или в системных меню.
    window = gtk_application_window_new(app);
    
    // Устанавливаем заголовок окна, который будет отображаться в строке заголовка.
    gtk_window_set_title(GTK_WINDOW(window), "GtkGrid Пример");
    
    // Устанавливаем размер окна по умолчанию (ширина, высота в пикселях).
    gtk_window_set_default_size(GTK_WINDOW(window), 300, 200);
    
    // Центрируем окно на экране при его первом появлении.
    gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER);

    // 2. Создание контейнера GtkGrid.
    // GtkGrid - это мощный контейнер, который позволяет располагать виджеты
    // в виде таблицы (по строкам и столбцам), предоставляя гибкий контроль
    // над их размещением и размерами.
    grid = gtk_grid_new();

    // 3. Настройка GtkGrid.
    // Устанавливаем внешний отступ (границы) вокруг всей сетки в 10 пикселей.
    // Это создаст "рамку" вокруг содержимого сетки.
    gtk_container_set_border_width(GTK_CONTAINER(grid), 10);
    
    // Устанавливаем фиксированный отступ в 5 пикселей между всеми строками в сетке.
    gtk_grid_set_row_spacing(GTK_GRID(grid), 5);
    
    // Устанавливаем фиксированный отступ в 5 пикселей между всеми столбцами в сетке.
    gtk_grid_set_column_spacing(GTK_GRID(grid), 5);

    // Дополнительные параметры GtkGrid (закомментировано для демонстрации):
    // gtk_grid_set_row_homogeneous(GTK_GRID(grid), TRUE);
    // Делает все строки в сетке одинаковой высоты, равной высоте самой высокой строки.
    // gtk_grid_set_column_homogeneous(GTK_GRID(grid), TRUE);
    // Делает все столбцы в сетке одинаковой ширины, равной ширине самого широкого столбца.

    // 4. Создание кнопок, которые будут размещены в сетке.
    // Создаем кнопки с различными текстовыми метками.
    button1 = gtk_button_new_with_label("Кнопка 1");
    button2 = gtk_button_new_with_label("Кнопка 2");
    button3 = gtk_button_new_with_label("Кнопка 3 (объединена)");
    button4 = gtk_button_new_with_label("Кнопка 4");

    // 5. Подключение обработчика кликов для каждой кнопки.
    // Все кнопки будут использовать одну и ту же callback-функцию on_button_clicked.
    // При нажатии любой из этих кнопок в консоли появится соответствующее сообщение.
    g_signal_connect(button1, "clicked", G_CALLBACK(on_button_clicked), NULL);
    g_signal_connect(button2, "clicked", G_CALLBACK(on_button_clicked), NULL);
    g_signal_connect(button3, "clicked", G_CALLBACK(on_button_clicked), NULL);
    g_signal_connect(button4, "clicked", G_CALLBACK(on_button_clicked), NULL);

    // 6. Добавление кнопок в сетку с использованием gtk_grid_attach().
    // Это ключевая функция для размещения виджетов в GtkGrid. Её параметры:
    //   - GTK_GRID(grid): Указатель на GtkGrid, в который добавляем виджет.
    //   - buttonN:         Виджет, который добавляется в сетку.
    //   - left:            Индекс столбца, с которого начинается виджет (0-индексированный).
    //                      0 - самый левый столбец.
    //   - top:             Индекс строки, с которой начинается виджет (0-индексированный).
    //                      0 - самая верхняя строка.
    //   - width:           Количество столбцов, которое занимает виджет (column-span).
    //                      Например, 2 означает, что виджет растянется на 2 столбца.
    //   - height:          Количество строк, которое занимает виджет (row-span).
    //                      Например, 2 означает, что виджет растянется на 2 строки.

    // Кнопка 1: Помещаем в ячейку (0,0), занимает 1 столбец, 1 строку.
    gtk_grid_attach(GTK_GRID(grid), button1, 0, 0, 1, 1);
    
    // Кнопка 2: Помещаем в ячейку (1,0), занимает 1 столбец, 1 строку.
    // Она будет находиться справа от Кнопки 1, в той же строке.
    gtk_grid_attach(GTK_GRID(grid), button2, 1, 0, 1, 1);
    
    // Кнопка 3: Помещаем в ячейку (0,1), занимает 2 столбца, 1 строку.
    // Это "объединенная" кнопка, которая растянется на первый и второй столбцы
    // во второй строке.
    gtk_grid_attach(GTK_GRID(grid), button3, 0, 1, 2, 1);
    
    // Кнопка 4: Помещаем в ячейку (0,2), занимает 1 столбец, 1 строку.
    // Она будет находиться под Кнопкой 1, в третьей строке.
    gtk_grid_attach(GTK_GRID(grid), button4, 0, 2, 1, 1);

    // 7. Добавление GtkGrid в окно.
    // GtkWindow (главное окно) может содержать только один прямой дочерний виджет.
    // Поэтому мы добавляем весь наш макет (GtkGrid) в это окно.
    gtk_container_add(GTK_CONTAINER(window), grid);

    // 8. Отображение всех виджетов.
    // По умолчанию все виджеты создаются невидимыми. Эта функция делает видимыми
    // главное окно, контейнер GtkGrid и все кнопки, которые находятся внутри сетки.
    gtk_widget_show_all(window);
}

/**
 * @brief Главная функция программы, точка входа.
 *
 * Эта функция является стандартной точкой входа для любого C-приложения.
 * Здесь происходит инициализация GtkApplication, подключение функции 'activate'
 * и запуск основного цикла приложения.
 *
 * @param argc Количество аргументов командной строки, переданных программе.
 * @param argv Массив строк аргументов командной строки.
 * @return Код завершения программы (0 при успешном выполнении).
 */
int main(int argc, char **argv) {
    GtkApplication *app; // Указатель на объект GtkApplication, представляющий наше приложение.
    int status;          // Переменная для хранения статуса завершения приложения.

    // Создание нового объекта GtkApplication.
    // "org.example.GridApp" - это уникальный идентификатор приложения (обычно в формате DNS),
    // который используется операционной системой для идентификации вашего приложения
    // (например, для группировки окон, настроек).
    // G_APPLICATION_FLAGS_NONE - базовые флаги приложения, без специфического поведения.
    app = gtk_application_new("org.example.GridApp", G_APPLICATION_DEFAULT_FLAGS);
    // Подключение сигнала "activate" к нашей функции 'activate'.
    // Сигнал "activate" испускается, когда приложение запускается и готово
    // создать свои окна или начать взаимодействие с пользователем.
    // G_CALLBACK(activate) - это макрос, который приводит указатель на функцию
    // к типу GCallback*, ожидаемому g_signal_connect.
    g_signal_connect(app, "activate", G_CALLBACK(activate), NULL);

    // Запуск приложения.
    // g_application_run() запускает главный цикл событий GLib (и GTK).
    // Управление передается библиотеке GTK, и приложение переходит в режим
    // ожидания и обработки пользовательских событий (кликов, нажатий клавиш и т.д.).
    // Функция возвращает статус завершения, когда приложение закрывается.
    status = g_application_run(G_APPLICATION(app), argc, argv);

    // Освобождение ресурсов, связанных с объектом GtkApplication.
    // Это важно для предотвращения утечек памяти. g_object_unref()
    // уменьшает счетчик ссылок на объект; когда счетчик достигает нуля,
    // объект уничтожается.
    g_object_unref(app);

    return status; // Возвращаем статус завершения приложения.
}