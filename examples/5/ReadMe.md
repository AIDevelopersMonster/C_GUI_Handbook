````markdown
# Глава 5: Указатели

Указатели — это мощная и фундаментальная особенность языка C. 
Они позволяют вам работать непосредственно с адресами памяти, где хранятся данные. 
Понимание указателей критически важно для работы с динамической памятью, массивами, строками, а также для эффективной передачи данных в функции.

**Что такое указатель?**

Представьте память вашего компьютера как длинный ряд почтовых ящиков. 
Каждый ящик имеет свой уникальный адрес (номер) и может хранить какое-то значение.

* **Обычная переменная** (`int x = 10;`) - это как сам почтовый ящик с адресом и значением внутри (например, ящик №1005, внутри лежит число 10).
* **Указатель** (`int *p;`) - это переменная, которая **хранит адрес другого почтового ящика**. То есть, указатель "знает", где находится другое значение. Он не хранит само значение, а хранит лишь его адрес.

**Основные концепции указателей в C:**

1.  **Объявление указателя:** Указатель объявляется с помощью символа `*` (звездочка), который указывает, что это переменная-указатель, а не обычная переменная.
    `тип *имя_указателя;`
    Пример: `int *ptr;` (ptr — это указатель на `int`).

2.  **Оператор адреса (`&`):** Амперсанд (`&`) используется для получения **адреса** переменной.
    Пример: `ptr = &variable_name;` (ptr теперь хранит адрес `variable_name`).

3.  **Оператор разыменования (`*`):** Звездочка (`*`) используется для **доступа к значению**, хранящемуся по адресу, на который указывает указатель.
    Пример: `*ptr` (даст вам значение, которое хранится по адресу, на который указывает `ptr`).

## 5.1. Введение в указатели: Объявление, Адрес и Разыменование

Этот раздел познакомит вас с базовыми понятиями: как объявить указатель, как получить адрес обычной переменной и как использовать указатель для доступа к значению по этому адресу.

### Демонстрация: `pointer_intro.c`

```c
// pointer_intro.c
// Введение в указатели: объявление, получение адреса и разыменование.

#include <stdio.h> // Для использования функции printf().

int main() {
    // 1. Объявление обычной переменной.
    // 'a' - это целочисленная переменная, хранящая значение 10.
    int a = 10;

    // 2. Объявление указателя и его инициализация.
    // 'int *p;': Объявляет 'p' как указатель, который будет указывать на область памяти,
    //            где хранится целое число (int). Звездочка '*' здесь означает "указатель на".
    // '&a': Оператор адреса ('&') возвращает адрес памяти, где хранится переменная 'a'.
    //       Таким образом, 'p' теперь хранит адрес 'a'.
    int *p = &a; 

    // 3. Вывод значений и адресов для демонстрации.
    printf("1. Значение переменной 'a': %d\n", a);        // Выводит содержимое 'a' (10).
    printf("2. Адрес переменной 'a' (&a): %p\n", &a);     // Выводит адрес 'a' в памяти.
                                                          // '%p' - спецификатор формата для вывода адресов (pointer).
    
    printf("3. Значение указателя 'p' (адрес, который он хранит): %p\n", p); 
                                                          // 'p' без '*' выводит адрес, который в нём хранится,
                                                          // то есть адрес 'a'.
    
    printf("4. Значение, на которое указывает 'p' (*p): %d\n", *p); 
                                                          // '*' здесь - оператор разыменования.
                                                          // Он позволяет получить ЗНАЧЕНИЕ, хранящееся по адресу,
                                                          // на который указывает 'p'. В данном случае, это значение 'a'.
    return 0; // Успешное завершение программы.
}
````

**Объяснение примера:**
В этом примере мы объявляем обычную переменную `a` со значением `10`. Затем объявляем указатель `p` типа `int*`. С помощью оператора `&` мы присваиваем `p` адрес переменной `a`. Далее, мы используем `printf` для вывода:

  * `a`: само значение переменной.
  * `&a`: адрес переменной `a`.
  * `p`: значение указателя `p`, которое, как вы увидите, совпадает с адресом `a`.
  * `*p`: значение, на которое указывает `p`, которое, конечно же, совпадает со значением `a`.

**Компиляция и запуск:**

```bash
gcc pointer_intro.c -o pointer_intro
./pointer_intro
```

**Ожидаемый вывод (адреса могут отличаться в вашей системе):**

```
1. Значение переменной 'a': 10
2. Адрес переменной 'a' (&a): 0x7ffee1f3e79c
3. Значение указателя 'p' (адрес, который он хранит): 0x7ffee1f3e79c
4. Значение, на которое указывает 'p' (*p): 10
```

### Демонстрация: `pointer5_1.c`

Аналогичный, более простой пример, который также показывает, как изменять значение переменной через указатель.

```c
// pointer5_1.c
#include <stdio.h>
void main (void)
{
int a;
int *ptr_to_a; // Объявляем указатель на int
ptr_to_a = &a; // Присваиваем указателю адрес переменной 'a'
a = 5;         // Присваиваем 'a' значение 5
printf ("The value of a is %d\n", a); // Выводим значение 'a'

*ptr_to_a = 6; // Изменяем значение по адресу, на который указывает 'ptr_to_a' (т.е. меняем 'a' на 6)
printf ("The value of a is %d\n", a); // Снова выводим значение 'a' - оно изменилось
printf ("The value of ptr_to_a is %p\n", (void *)ptr_to_a); // Выводим значение самого указателя (адрес)
printf ("It stores the value %d\n", *ptr_to_a); // Выводим значение, на которое указывает указатель
printf ("The address of a is %p\n", (void *)&a); // Выводим адрес переменной 'a'
}
```

**Объяснение примера:**
Этот пример подтверждает, что, изменив значение через оператор разыменования (`*ptr_to_a = 6;`), мы фактически изменяем оригинальную переменную (`a`). Обратите внимание на использование `%p` для вывода адресов.

**Компиляция и запуск:**

```bash
gcc pointer5_1.c -o pointer5_1
./pointer5_1
```

**Ожидаемый вывод (адреса могут отличаться):**

```
The value of a is 5
The value of a is 6
The value of ptr_to_a is 0x7ffc76d209ac
It stores the value 6
The address of a is 0x7ffc76d209ac
```

## 5.2. Объявление указателей различных типов

Указатели могут указывать на переменные любого типа данных. Тип указателя должен совпадать с типом переменной, на которую он указывает, чтобы компилятор знал, сколько байт памяти нужно интерпретировать по этому адресу.

### Демонстрация: `declare_pointer.c`

```c
// declare_pointer.c
// Пример объявления и инициализации указателя разных типов.

#include <stdio.h> // Для использования функции printf().

int main() {
    // Объявление указателя на float.
    // 'float *ptr;': 'ptr' может хранить адрес переменной типа 'float'.
    float *ptr;      

    // Объявляем обычную переменную типа float.
    float x = 3.14;  

    // Инициализация указателя: присваиваем 'ptr' адрес переменной 'x'.
    ptr = &x;        

    // Демонстрация значений и адресов.
    printf("Значение переменной x: %f\n", x);
    printf("Адрес переменной x (&x): %p\n", &x);
    printf("Значение указателя ptr (адрес x): %p\n", ptr);
    printf("Значение, на которое указывает ptr (*ptr): %f\n", *ptr);

    // Можно объявить и инициализировать указатель сразу:
    double pi = 3.14159;
    double *ptr_to_pi = &pi; // Указатель на double, сразу указывает на 'pi'.

    printf("\n--- Дополнительный пример с double ---\n");
    printf("Значение pi: %lf\n", pi); // %lf для double
    printf("Адрес pi (&pi): %p\n", &pi);
    printf("Значение ptr_to_pi: %p\n", ptr_to_pi);
    printf("Значение, на которое указывает ptr_to_pi (*ptr_to_pi): %lf\n", *ptr_to_pi);

    return 0; // Успешное завершение программы.
}
```

**Объяснение примера:**
Здесь мы видим, что указатели могут быть объявлены для разных типов данных (например, `float *` для `float`, `double *` для `double`). Важно помнить, что тип указателя определяет, сколько байтов памяти компилятор будет "читать", когда вы разыменовываете указатель (`*ptr`).

**Компиляция и запуск:**

```bash
gcc declare_pointer.c -o declare_pointer
./declare_pointer
```

**Ожидаемый вывод (адреса могут отличаться):**

```
Значение переменной x: 3.140000
Адрес переменной x (&x): 0x7ffe102c98d4
Значение указателя ptr (адрес x): 0x7ffe102c98d4
Значение, на которое указывает ptr (*ptr): 3.140000

--- Дополнительный пример с double ---
Значение pi: 3.141590
Адрес pi (&pi): 0x7ffe102c98c8
Значение ptr_to_pi: 0x7ffe102c98c8
Значение, на которое указывает ptr_to_pi (*ptr_to_pi): 3.141590
```

## 5.3. Изменение значения переменной через указатель

Одна из самых мощных возможностей указателей — это способность изменять значение оригинальной переменной, не обращаясь к ней напрямую, а делая это через указатель на неё.

### Демонстрация: `modify_via_pointer.c`

```c
// modify_via_pointer.c
// Пример изменения значения переменной через указатель.

#include <stdio.h> // Для использования функции printf().

int main() {
    // 1. Объявляем обычную целочисленную переменную 'x'.
    int x = 5;       

    // 2. Объявляем указатель 'p' и инициализируем его адресом 'x'.
    int *p = &x;     

    printf("До изменения: x = %d\n", x); // Выведет: До изменения: x = 5

    // 3. Изменяем значение переменной 'x' через указатель 'p'.
    // Оператор разыменования '*' здесь используется для доступа к области памяти,
    // на которую указывает 'p'. Мы присваиваем новое значение (10) этой области.
    // Это приводит к изменению оригинальной переменной 'x'.
    *p = 10; 

    printf("После изменения: x = %d\n", x); // Выведет: После изменения: x = 10
    // Убедимся, что указатель также "видит" новое значение.
    printf("Значение через *p: %d\n", *p);  // Выведет: Значение через *p: 10

    return 0; // Успешное завершение программы.
}
```

**Объяснение примера:**
Изначально `x` равно `5`. Мы создаем указатель `p`, который "смотрит" на `x`. Затем, используя `*p = 10;`, мы говорим: "перейди по адресу, который хранится в `p`, и запиши туда значение `10`". Поскольку `p` хранит адрес `x`, это действие изменяет значение `x` на `10`.

**Компиляция и запуск:**

```bash
gcc modify_via_pointer.c -o modify_via_pointer
./modify_via_pointer
```

**Ожидаемый вывод:**

```
До изменения: x = 5
После изменения: x = 10
Значение через *p: 10
```

## 5.4. Передача аргументов в функцию по указателю (Call by Reference)

Одним из наиболее частых применений указателей является передача аргументов в функцию "по ссылке" (call by reference). В C, по умолчанию, аргументы передаются "по значению" (call by value), что означает, что функция получает копию переменной и не может изменить оригинал. Передача по указателю позволяет функции изменять оригинальную переменную.

### Демонстрация: `call_by_reference.c`

```c
// call_by_reference.c
// Пример передачи аргументов в функцию по указателю (Call by Reference)
// для изменения оригинальной переменной.

#include <stdio.h> // Для использования функции printf().

// 1. Объявление функции setZero.
// Эта функция принимает ОДИН АРГУМЕНТ: указатель на целое число (int *n).
// Это означает, что она ожидает получить АДРЕС переменной типа int.
void setZero(int *n) {
    // 2. Внутри функции:
    // Оператор разыменования '*' используется для доступа к ЗНАЧЕНИЮ,
    // которое находится по адресу, хранящемуся в 'n'.
    // Присваивая 0 к *n, мы напрямую изменяем содержимое памяти
    // оригинальной переменной, адрес которой был передан.
    *n = 0; 
    printf("  Внутри функции setZero: Значение по адресу *n = %d\n", *n);
}

int main() {
    int a = 42; // Объявляем обычную переменную 'a' со значением 42.

    printf("До вызова функции setZero: a = %d\n", a); // Выведет: До вызова функции setZero: a = 42

    // 3. Вызов функции setZero.
    // Мы передаем АДРЕС переменной 'a' (используя оператор '&a').
    // Таким образом, функция setZero получает возможность работать
    // непосредственно с оригинальной переменной 'a'.
    setZero(&a); 

    printf("После вызова функции setZero: a = %d\n", a); // Выведет: После вызова функции setZero: a = 0
                                                          // Значение 'a' изменилось!

    return 0; // Успешное завершение программы.
}
```

**Объяснение примера:**
Функция `setZero` объявлена так, чтобы принимать `int *n` (указатель на целое число). Когда мы вызываем `setZero(&a);`, мы передаем **адрес** переменной `a`. Внутри функции `setZero`, `*n = 0;` разыменовывает указатель `n` (получает доступ к значению по адресу, который он хранит) и присваивает этому значению `0`. Поскольку `n` хранит адрес `a`, это эффективно изменяет значение `a` в `main`.

**Компиляция и запуск:**

```bash
gcc call_by_reference.c -o call_by_reference
./call_by_reference
```

**Ожидаемый вывод:**

```
До вызова функции setZero: a = 42
  Внутри функции setZero: Значение по адресу *n = 0
После вызова функции setZero: a = 0
```

## 5.5. Указатель на указатель (Pointer to Pointer)

Указатель на указатель — это переменная, которая хранит адрес другого указателя. Это создает цепочку указателей.

### Синтаксис:

```c
тип **имя_указателя_на_указатель;
```

### Демонстрация: `pointer_to_pointer.c`

```c
// pointer_to_pointer.c
// Пример использования указателя на указатель.

#include <stdio.h> // Для использования функции printf().

int main() {
    // 1. Обычная переменная.
    int x = 7;       

    // 2. Указатель на int.
    // 'p' хранит адрес 'x'. 'p' указывает на 'x'.
    int *p = &x;     

    // 3. Указатель на указатель на int.
    // 'int **pp;': 'pp' - это указатель, который указывает на другой указатель,
    //              который, в свою очередь, указывает на 'int'.
    // '&p': 'pp' хранит адрес 'p'.
    // Таким образом, 'pp' -> 'p' -> 'x'.
    int **pp = &p;   

    printf("Значение x: %d\n", x);           // Выводит значение 'x' (7).
    printf("Адрес x: %p\n", &x);             // Выводит адрес 'x' в памяти.

    printf("\nЗначение p (адрес x): %p\n", p); // Выводит адрес, хранящийся в 'p' (т.е., адрес 'x').
    printf("Адрес p: %p\n", &p);             // Выводит собственный адрес 'p' в памяти.

    printf("\nЗначение pp (адрес p): %p\n", pp); // Выводит адрес, хранящийся в 'pp' (т.е., адрес 'p').
    printf("Адрес pp: %p\n", &pp);           // Выводит собственный адрес 'pp' в памяти.

    printf("\nДоступ к значениям через указатели:\n");
    printf("Значение через *p: %d\n", *p);     // Разыменование 'p' дает значение 'x'.
    printf("Значение через **pp: %d\n", **pp); // Двойное разыменование 'pp' дает значение 'x'.
                                                // *pp сначала дает значение 'p' (адрес 'x'),
                                                // а затем второе * разыменовывает этот адрес, давая значение 'x'.

    // Изменение значения через указатель на указатель
    **pp = 15; // Изменяем значение x через pp
    printf("\nЗначение x после изменения через **pp: %d\n", x); // x теперь 15.

    return 0; // Успешное завершение программы.
}
```

**Объяснение примера:**
Мы имеем `x` (обычную переменную), `p` (указатель на `x`) и `pp` (указатель на `p`).

  * `x` хранит `7`.
  * `p` хранит адрес `x`.
  * `pp` хранит адрес `p`.

Когда вы используете `**pp`, это означает:

1.  `*pp`: Получить значение, на которое указывает `pp`. Поскольку `pp` указывает на `p`, это дает нам значение `p` (то есть, адрес `x`).
2.  `* (адрес_x)`: Теперь разыменовать этот адрес `x`, чтобы получить значение, хранящееся по адресу `x`, то есть `7`.

Таким образом, `**pp` в конечном итоге дает вам доступ к оригинальной переменной `x`. Это полезно в более сложных структурах данных и функциях, где вам нужно передать указатель на указатель для изменения самого указателя.

**Компиляция и запуск:**

```bash
gcc pointer_to_pointer.c -o pointer_to_pointer
./pointer_to_pointer
```

**Ожидаемый вывод (адреса могут отличаться):**

```
Значение x: 7
Адрес x: 0x7ffe102c98d4

Значение p (адрес x): 0x7ffe102c98d4
Адрес p: 0x7ffe102c98d8

Значение pp (адрес p): 0x7ffe102c98d8
Адрес pp: 0x7ffe102c98e0

Доступ к значениям через указатели:
Значение через *p: 7
Значение через **pp: 7

Значение x после изменения через **pp: 15
```

## 5.6. `void` указатели (Generic Pointers)

`void` указатель (или универсальный указатель) может хранить адрес памяти любого типа данных. Он "указывает на что-то неизвестного типа".

### Синтаксис:

```c
void *имя_void_указателя;
```

**Особенности `void` указателей:**

  * Они не имеют связанного типа данных, поэтому компилятор не знает, сколько байтов нужно "читать" или записывать, когда вы разыменовываете `void*`.
  * Вы **не можете напрямую разыменовать** `void` указатель (`*vptr`). Сначала его нужно привести к конкретному типу указателя.
  * Они часто используются в функциях, которые работают с данными различных типов (например, функции выделения памяти, такие как `malloc`).

### Демонстрация: `myvoidpointer.c`

```c
// myvoidpointer.c
#include <stdio.h>
void main (void)
{
int intval = 255958283; // Целое число
void *vptr = &intval;   // Объявляем void-указатель и присваиваем ему адрес intval

// Чтобы разыменовать void-указатель, его нужно привести к конкретному типу.
// Здесь мы приводим vptr к int* и затем разыменовываем его.
printf ("The value at vptr as an int is %d\n", *((int *) vptr));

// Приводим vptr к char* и разыменовываем.
// Это может показать только первый байт (или первый символ, если бы это был char),
// так как char имеет размер 1 байт. Зависит от порядка байтов в системе (endianness).
printf ("The value at vptr as a char is %d\n", *((char *) vptr));
}
```

**Объяснение примера:**
`vptr` может хранить адрес `intval`. Однако, чтобы получить доступ к значению через `vptr`, мы должны явно указать компилятору, какой тип данных находится по этому адресу.

  * `*((int *) vptr)`: Мы говорим "рассматривай `vptr` как указатель на `int`, а затем разыменуй его". Это корректно извлекает целое число.
  * `*((char *) vptr)`: Мы говорим "рассматривай `vptr` как указатель на `char`, а затем разыменуй его". Поскольку `char` занимает 1 байт, это выведет значение только первого байта из `intval`. Результат может быть неочевиден без понимания двоичного представления чисел и порядка байтов.

**Компиляция и запуск:**

```bash
gcc myvoidpointer.c -o myvoidpointer
./myvoidpointer
```

**Ожидаемый вывод (значение char может отличаться в зависимости от архитектуры/порядка байтов):**

```
The value at vptr as an int is 255958283
The value at vptr as a char is -109 
```

*(Примечание: `-109` для `char` получается, потому что `255958283` в шестнадцатеричном виде это `0xF30B0BAD`. Если система little-endian (как большинство), то младший байт `0xAD` (173 десятичное) читается как `char`. Если `char` знаковый, `173` интерпретируется как `-83` или `-109` в зависимости от платформы. Важно понимать, что `char` здесь читает только 1 байт из 4-байтного `int`.)*

## Как скомпилировать и запустить файлы (`.c`)

Для компиляции и запуска этих программ на Raspberry Pi Zero 2 W (или любой другой системе с установленным GCC) выполните следующие шаги в терминале:

1.  **Откройте терминал:** Перейдите в каталог, где сохранены ваши `.c` файлы.
2.  **Компиляция:** Используйте компилятор `gcc`.
    Например, для `pointer_intro.c`:
    ```bash
    gcc pointer_intro.c -o pointer_intro
    ```
      * `gcc`: Исполняемый файл компилятора GNU C.
      * `pointer_intro.c`: Исходный файл, который вы хотите скомпилировать.
      * `-o pointer_intro`: Опция `-o` указывает имя выходного исполняемого файла (в данном случае `pointer_intro`). Если эту опцию опустить, исполняемый файл по умолчанию будет называться `a.out`.
3.  **Запуск:** Запустите скомпилированный исполняемый файл.
    ```bash
    ./pointer_intro
    ```
      * `./`: Указывает операционной системе искать исполняемый файл в текущем каталоге.

Повторите эти шаги для каждого файла `.c`, чтобы скомпилировать и запустить их.

-----

**Краткий конспект Главы 5 (для меня):**

  * **Тема:** Указатели.
  * **Суть указателей:** Переменные, которые хранят адреса других переменных. Позволяют напрямую работать с памятью.
  * **Ключевые операторы:**
      * `*` (звездочка):
          * При объявлении: `int *ptr;` (указатель на `int`).
          * При использовании: `*ptr` (разыменование, доступ к значению по адресу).
      * `&` (амперсанд): `&variable` (оператор адреса, получить адрес `variable`).
  * **Ключевые понятия:**
      * **Объявление:** Тип указателя должен соответствовать типу данных, на которые он указывает.
      * **Изменение через указатель:** `*ptr = value;` изменяет оригинальную переменную.
      * **Передача по ссылке (Call by Reference):** Передача адресов переменных в функции позволяет функциям изменять оригинальные переменные.
      * **Указатель на указатель (`**pp`):** Указатель, который хранит адрес другого указателя. Используется для косвенного доступа и изменения указателей.
      * **`void` указатели (`void *vptr`):** Универсальные указатели, которые могут хранить адрес любого типа данных. Требуют приведения типа перед разыменованием.
  * **Демонстрационные файлы:** `pointer_intro.c`, `pointer5_1.c`, `declare_pointer.c`, `modify_via_pointer.c`, `call_by_reference.c`, `pointer_to_pointer.c`, `myvoidpointer.c`.
  * **Инструкции:** Компиляция (`gcc`) и запуск (`./`).

<!-- end list -->

```
```